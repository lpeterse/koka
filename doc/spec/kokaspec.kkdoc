<!DOCTYPE html>
<html>
<!-- NO_CLICK_TRACKING -->
<!--
  Copyright 2012 Microsoft Corporation.
 
  This is free software; you can redistribute it and/or modify it under the
  terms of the Apache License, Version 2.0. A copy of the License can be
  found in the file "license.txt" at the root of this distribution.
-->

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />

<style type="text/css">
.koka .plaincode, .koka a.pp .pc { display: none; } .koka a.pp { color: inherit; text-decoration: none; }
</style>
<link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=PT+Sans'>
<link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Source+Code+Pro'>
<link rel="stylesheet" type="text/css" href="styles/koka.css" /> 
<style type="text/css">
body {
  margin: 2em 12% 2em 8%;
}

h3 {
  font-size: 120%;
}

p {
  text-align: justify;
}

.koka.source,
.koka.source.unchecked {
  margin-left: 2ex;  
  background-color: white;
  border: none;
  /* border-left: 1px solid #DDD; */
}

.koka.source.unchecked {
  /* border-left: 1px dashed #DDD ; */
}

.grammar table,
table.grammar  {   
  margin: 0.5ex 0.5ex 0.5ex 2ex;
  padding: 0.5ex 1ex 0.5ex 1ex;
  /*
  background-color: #FAFAFA;
  border: solid 1px #DDD;
  */
}

.grammar .code,
.grammar code {
  padding: 0pt;
}

.grammar .bar {
  padding: 0ex 0.5ex;
}

.grammar td:nth-child(2) {
  font-style: normal; 
  padding: 0em 1ex;
  text-align: center;
}

.grammar .thin,
.grammar .bar
.grammar td:nth-child(2) {
  font-family: Georgia, sans-serif;  /* a thinner font, widely available */
}


.grammar td:nth-child(4) {
  font-style: normal; 
  padding-left: 2ex;
}

.grammar td {
  white-space: nowrap;
}
.grammar .code, .grammar code,
.grammar .pre, .grammar pre {
  font-weight: bold;
}

table .kw, table .tp, table .co,
.grammar .keyword, .grammar .kw,
.grammar .type, .grammar .tp,
.grammar .constructor, .grammar .co {
  color: black;
}

.nt {
  font-style: italic;
}          

.opt, .many {   
  padding: 0ex 0.5ex;
}

#toc {
  display: none;
}

#toc li>a,
.toc-num>a {
  color: black;
  text-decoration: none;
}
#toc li>a:hover,
.toc-num>a:hover {
  color: black;
  border-bottom: 1px dotted blue;
}
#toc li {
  padding-top: 0.1ex;
}
#toc>div>ul>li {
  padding-top: 0.25ex;
}

#toc ul {
  list-style-type: none;
  margin-left: 0ex;
  padding-left: 0ex;
} 
#toc ul {
  font-size: 110%;
}

#toc ul ul {
  margin-left: 1.5em;
  font-size: 90%;
}

.toc-num {
  font-size: 80%;
  margin-right: 0.5em;
}

#toc-toggle {
  cursor: pointer;
  vertical-align: center;
  margin-right: 10px;
  font-size: 16pt;
}
</style>

<script type='text/javascript'>

function genTOC() {
  var toc = document.getElementById('toc');  
  if (toc == null) return;
  var tocToggle = document.getElementById('toc-toggle');
  
  function showToc() {
    toc.style.display = 'block';
    if (tocToggle){
      tocToggle.innerHTML = '&#x25BC;'
      tocToggle.style.fontSize = '12pt'
    }
  }
  function hideToc() {
    toc.style.display = 'none';
    if (tocToggle) {
      tocToggle.innerHTML = '&#x25B6;';    
      tocToggle.style.fontSize = '16pt';
    }
  }
  function switchToc() {
    (toc.style.display != 'none' ? hideToc() : showToc());
  }

  if (tocToggle) tocToggle.onclick = switchToc;
  hideToc()
}

function genFullGrammar() {
  var fullLex = "";
  var fullParse = "";
  var divLex = document.getElementById("full-lexical");
  var divGrammar = document.getElementById("full-grammar");
  if (!divLex || !divGrammar) return;

  var gs = document.getElementsByClassName("grammar");
  for(var i = 0; i < gs.length; i++) {
    var elem = gs[i];
    if (elem.tagName.toLowerCase() != "table") continue;
    if (elem.className.indexOf("lex") >= 0) fullLex += elem.innerHTML;
    else if (elem.className.indexOf("parse") >= 0) fullParse += elem.innerHTML;
  }
  divLex.innerHTML="<table class='grammar'>\n"+ fullLex + "</table>"; 
  divGrammar.innerHTML="<table class='grammar'>\n" + fullParse + "</table>";
}

window.onload = function() { genTOC(); genFullGrammar() };
</script>
<title>Koka language specification</title>
</head>

<body>

<!-- <div id="toc">
<h2 class="notoc"><span id="toc-toggle"></span>Table of contents</h2>
</div>
-->

<xmp>

## <span id="toc-toggle"></span> Table of contents {-}
[TOC]

# Koka language specification

This is the draft language specification of the Koka language, version 0.1.<br>
Currently only the lexical and context-free grammar and the layout rule are specified. 
The [standard libraries](toc.html) are documented separately.

# Lexical syntax

We define the grammar and lexical syntax of the language using standard BNF
notation where non-terminals are generated by alternative patterns:

  |  |  |  
--- | --- | --- | ---
_nonterm_ | ::= | _pattern_<sub>1</sub> <span class="bar">&#124;</span> _pattern_<sub>2</sub> | 
{.grammar}


In the patterns, we use the following notations:

  |  |  |  
--- | --- | --- | ---
"terminal" |  |  | A terminal symbol
`x0A` |  |  | A character with hexadecimal code 0A
`a..f` |  |  | The characters from a to f
&nbsp; | |  |  |
( _pattern_ ) |  |  | Grouping
[ _pattern_ ] |  |  | Optional occurrence of _pattern_
{ _pattern_ } |  |  | Zero or more occurrences of _pattern_
_pattern_<sub>1</sub> <span class="bar">&#124;</span> _pattern_<sub>2</sub> | |  | Choice: either _pattern_<sub>1</sub> or _pattern_<sub>2</sub>
&nbsp; | |  |  |
_pattern_<sub>&lt;_diff_&gt;</sub> |  |  | Difference: elements generated by _pattern_ except those in _diff_
_nonterm_<sub>[_lex_]</sub> |  |  | Generate _nonterm_ by drawing lexemes from _lex_
{.grammar}

<span class="grammar">Care must be taken to distinguish meta-syntax such as 
<span class="thin">&#124;</span> and ) from concrete terminal symbols as `|` and `)`.</span>

## Source code

Source code consists of a sequence of 8-bit characters. Valid characters in
actual program code consists strictly of ASCII characters which range from 0
to 127 and can be encoded in 7-bits. Only comments, string literals, and
character literals are allowed to contain extended 8-bit characters. This
means that one cannot write identifiers or operators that use unicode symbols.

## Encoding

A program source is assumed to be UTF-8 encoded which allows comments, string
literals, and character literals to contain (encoded) unicode characters.
Moreover, the grammer is designed such that a lexical analyzer and parser can
directly work on source files without doing UTF-8 decoding or unicode category
identification. To further facilitate the processing of UTF-8 encoded files
the lexical analyzer ignores an initial byte-order mark that some UTF-8
encoders insert. In particular, any program source is allowed to start with
three byte-order mark bytes `0xEF`, `0xBB`, and `0xBF`, which are ignored.

## Lexical grammar

In the specification of the lexical grammar all white space is explicit and
there is no implicit white space between juxtaposed symbols. The lexical token
stream is generated by the non-terminal _lex_ which consists of lexemes and
whitespace.

Before doing lexical analysis, there is a _linefeed_ character inserted at the
start and end of the input, which makes it easier to specify line comments and
directives. 

### Lexical tokens

 | | |  
 --- | --- | --- | ---
_lex_  |  ::= | <span class="many">{ _whitespace_ <span class="bar">&#124;</span> _lexeme_ }</span>
_lexeme_&nbsp;&nbsp; | ::= | _conid_ <span class="bar">&#124;</span> _qconid_
 | &#124; | _varid_ <span class="bar">&#124;</span> _qvarid_
 | &#124; | _op_ <span class="bar">&#124;</span> _opid_ <span class="bar">&#124;</span> _qopid_ <span class="bar">&#124;</span> _wildcard_
 | &#124; | _natural_ <span class="bar">&#124;</span> _float_ <span class="bar">&#124;</span> _string_ <span class="bar">&#124;</span> _char_
 | &#124; | _reserved_ <span class="bar">&#124;</span> _reservedop_ <span class="bar">&#124;</span> _special_
{.grammar .lex}

### Identifiers

 | | |  
--- | --- | --- | ---
_qconid_ | ::= | _modulepath_ _conid_
_qvarid_ | ::= | _modulepath_ _lowerid_  
_modulepath_ | ::= | _lowerid_ "/" <span class="many">{ _lowerid_ "/" }</span>
&nbsp; | | 
_conid_ | ::= | _upperid_
_varid_ | ::= | _lowerid_<sub>&lt;_reserved_&gt;</sub>
&nbsp; | | 
_lowerid_ | ::= | _lower_ <span class="many">{ _idchar_ }</span> 
_upperid_ | ::= | _upper_ <span class="many">{ _idchar_ }</span>
_idchar_ | ::= | _letter_ <span class="bar">&#124;</span> _digit_ <span class="bar">&#124;</span> `_` 
&nbsp; | | 
_wildcard_ | ::= | `_` <span class="many">{ _idchar_ }</span>
_typevarid_ | ::= | _letter_ <span class="many">{ _digit_ }</span>
&nbsp; | | 
_reserved_ | ::= | "infix" <span class="bar">&#124;</span> "infixr" <span class="bar">&#124;</span> "infixl" <span class="bar">&#124;</span> "prefix" 
  | &#124; | "type" <span class="bar">&#124;</span> "cotype" <span class="bar">&#124;</span> "rectype" <span class="bar">&#124;</span> "alias" 
  | &#124; | "forall" <span class="bar">&#124;</span> "exists" <span class="bar">&#124;</span> "some"
 | &#124; | "fun" <span class="bar">&#124;</span> "function" <span class="bar">&#124;</span> "val" <span class="bar">&#124;</span> "var" <span class="bar">&#124;</span> "con"
 | &#124; | "if" <span class="bar">&#124;</span> "then" <span class="bar">&#124;</span> "else" <span class="bar">&#124;</span> "elif" <span class="bar">&#124;</span> "match" <span class="bar">&#124;</span> "return"
 | &#124; | "module" <span class="bar">&#124;</span> "import" <span class="bar">&#124;</span> "as"
 | &#124; | "public" <span class="bar">&#124;</span> "private" <span class="bar">&#124;</span> "abstract" 
 | &#124; | "interface" <span class="bar">&#124;</span> "instance" <span class="bar">&#124;</span> "with"
 | &#124; | "external" <span class="bar">&#124;</span> "inline" <span class="bar">&#124;</span> "include"
 | &#124; | "yield" <span class="bar">&#124;</span> "qualified" <span class="bar">&#124;</span> "hiding"  | (future reserved words)
{.grammar .lex}

### Operators and symbols

 | | | 
--- | --- | --- | ---  
_qopid_ | ::= | _modulepath_ _opid_ 
_opid_ | ::= | "(" _symbols_ ")"
&nbsp; | |
_op_ | ::= | _symbols_<sub>&lt;_reservedop_ <span class="bar">&#124;</span> _typeop_&gt;</sub>
&nbsp; | |
_symbols_ | ::= | _symbol_ <span class="many">{ _symbol_ } <span class="bar">&#124;</span> `/`</span>
_symbol_ | ::= | "$" <span class="bar">&#124;</span> "%" <span class="bar">&#124;</span> `&` <span class="bar">&#124;</span> "*" <span class="bar">&#124;</span> "+"
 | &#124; | `"` <span class="bar">&#124;</span> "!" <span class="bar">&#124;</span> "\" <span class="bar">&#124;</span> "^" <span class="bar">&#124;</span> `#`
 | &#124; | `=` <span class="bar">&#124;</span> `.` <span class="bar">&#124;</span> `:` <span class="bar">&#124;</span> "-" <span class="bar">&#124;</span> "?"
 | &#124; | <span class="koka code">&#124;</span> <span class="bar">&#124;</span> "<" <span class="bar">&#124;</span> ">"
&nbsp; | |
_special_ | ::= | "{" <span class="bar">&#124;</span> "}" <span class="bar">&#124;</span> "(" <span class="bar">&#124;</span> ")" <span class="bar">&#124;</span> "[" <span class="bar">&#124;</span> "]" <span class="bar">&#124;</span> ";" <span class="bar">&#124;</span> "," <span class="bar">&#124;</span><code>&#96;</code>
&nbsp; | |
_reservedop_ | ::= | "=" <span class="bar">&#124;</span> "." <span class="bar">&#124;</span> <span class="koka code keyword">:</span> <span class="bar">&#124;</span> "->"
_typeop_ | ::= | ">" _anglebar_ <span class="many">{ _anglebar_ }</span>    
 | &#124; | "<" _anglebar_ <span class="many">{ _anglebar_ }</span>
 | &#124; | <span class="koka code">&#124;</span> _angle_ <span class="many">{ _symbol_ }</span>
 | &#124; | "-><" <span class="many">{ _symbol_ }</span>
 | &#124; | `:?` <span class="many">{ _symbol_ }</span>
&nbsp; | |
_anglebar_ | ::= | <span class="koka code">&#124;</span> <span class="bar">&#124;</span> _angle_
_angle_ | ::= | "<" <span class="bar">&#124;</span> ">"
{.grammar .lex}

### Literals

 | | |  
--- | --- | --- | ---
_string_ | ::= | `@"` <span class="many">{ _graphic_<sub>&lt;`"`&gt;</sub> <span class="bar">&#124;</span> _utf8_ <span class="bar">&#124;</span> _space_ <span class="bar">&#124;</span> _tab_ <span class="bar">&#124;</span> _newline_ <span class="bar">&#124;</span> `""` }</span> `"` | (raw string)
 | &#124; | `"` <span class="many">{ _graphic_<sub>&lt;`"`<span>&#124;</span>`\`&gt;</sub> <span class="bar">&#124;</span> _utf8_ <span class="bar">&#124;</span> _space_ <span class="bar">&#124;</span> _escape_ }</span> `"`
_char_ | ::= | `'` ( _graphic_<sub>&lt;`'`<span>&#124;</span>`\`&gt;</sub> <span class="bar">&#124;</span> _utf8_ <span class="bar">&#124;</span> _space_ <span class="bar">&#124;</span> _escape_ ) `'`
&nbsp; | |
_escape_ | ::= | `\` ( _charesc_ <span class="bar">&#124;</span> _hexesc_ )
_charesc_ | ::= | "n" <span class="bar">&#124;</span> "r" <span class="bar">&#124;</span> "t" <span class="bar">&#124;</span> `\` <span class="bar">&#124;</span> `"` <span class="bar">&#124;</span> `'` 
_hexesc_ | ::= | "x" _hexdigit_<sub>2</sub> <span class="bar">&#124;</span>   "u" _hexdigit_<sub>4</sub> <span class="bar">&#124;</span>   `U` _hexdigit_<sub>4</sub> _hexdigit_<sub>2</sub>
_hexdigit_<sub>4</sub> | ::= | _hexdigit_ _hexdigit_ _hexdigit_ _hexdigit_
_hexdigit_<sub>2</sub> | ::= | _hexdigit_ _hexdigit_
&nbsp; | |
_float_ | ::= | _decimal_ "." _decimal_ <span class="opt">[_exponent_]</span>
_exponent_ | ::= | (`e` &#124; `E`) <span class="opt">[`-` &#124; "+"]</span> _decimal_
_natural_ | ::= | _decimal_ <span class="bar">&#124;</span> "0" &nbsp; (`x` &#124; `X`) _hexadecimal_
_decimal_ | ::= | _digit_ <span class="many">{ _digit_ }</span>
_hexadecimal_ | ::= | _hexdigit_ <span class="many">{ _hexdigit_ }</span>
{.grammar .lex}

### White space

 | | |  
--- | --- | --- | ---
_whitespace_ | ::= | _white_ <span class="many">{ _white_ }</span>
_white_ | ::= | _newline_ <span class="bar">&#124;</span> _space_
 | &#124; | _linecomment_ <span class="bar">&#124;</span> _blockcomment_
 | &#124; | _linedirective_  
&nbsp; | |
_linecomment_ | ::= | `//` <span class="many">{ _linechar_ }</span> _newline_
_linedirective_ | ::= | _newline_ `#` <span class="many">{ _linechar_ } _newline_</span>
_linechar_ | ::= | _graphic_ <span class="bar">&#124;</span> _utf8_ <span class="bar">&#124;</span> _space_ <span class="bar">&#124;</span> _tab_
&nbsp; | |
_blockcomment_ | ::= | <code>/&#42;</code> _blockpart_ <span class="many">{ _blockcomment_ _blockpart_ }</span> <code>&#42;/</code> | (allows nested comments)
_blockpart_ | ::= | _blockchars_<sub>&lt;_blockchars_ (<code>/&#42;</code><span class="bar">&#124;</span><code>&#42;/</code>) _blockchars_&gt;</sub>
_blockchars_ | ::= | <span class="many">{ _blockchar_ }</span>
_blockchar_ | ::= | _graphic_ <span class="bar">&#124;</span> _utf8_ <span class="bar">&#124;</span> _space_ <span class="bar">&#124;</span> _tab_ <span class="bar">&#124;</span> _newline_
{.grammar .lex}

### Character classes

 | | |  
--- | --- | --- | ---
_letter_  | ::= | _upper_ <span class="bar">&#124;</span> _lower_
_upper_   | ::= | `A..Z`
_lower_   | ::= | `a..z`
_digit_   | ::= | `0..9`
_hexdigit_| ::= | `a..f` <span class="bar">&#124;</span> `A..F` <span class="bar">&#124;</span> _digit_
&nbsp; |    |
_newline_ | ::= | <span class="opt">[_return_]</span> _linefeed_ | (windows or unix style end of line)
&nbsp; |    |
_space_   | ::= | `x20` | (a space)
_tab_     | ::= | `x09` | (a tab (`\t`))
_linefeed_| ::= | `x0A` | (a line feed (`\n`))
_return_  | ::= | `x0D` | (a carriage return (`\r`))
_graphic_ | ::= | `x21`..`x7E` | (a visible character)
&nbsp; |    |
_utf8_    | ::= | `xC0` `x80` | (encoded 0 character)
 | &#124; | (`xC2`..`xDF`) _cont_  
 | &#124; | `xE0` (`xA0`..`xBF`) _cont_ 
 | &#124; | (`xE1`..`xEC`) _cont_ _cont_ 
 | &#124; | `xED` (`x80`..`x9F`) _cont_ 
 | &#124; | (`xEE`..`xEF`) _cont_ _cont_ 
 | &#124; | `xF0` (`x90`..`xBF`) _cont_ _cont_ 
 | &#124; | (`xF1`..`xF3`) _cont_ _cont_ _cont_ 
 | &#124; | `xF4` (`x80`..`x8F`) _cont_ _cont_
_cont_ | ::= | `x80`..`xBF`            
{.grammar .lex}

## Semicolon insertion  {#sec:layout}

Just like programming languages like 
[Haskell], [Python], [JavaScript], [Scala], [Go], etc., there is a layout rule
which automatically adds semicolons at appropiate places. This enables the
programmer to leave out most semicolons.

  [Haskell]: http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3  
  [Python]: http://docs.python.org/2/reference/lexical_analysis.html
  [JavaScript]: http://bclary.com/2004/11/07/index.html#a%2D7%2E9
  [Scala]: http://books.google.com/books?id=MFjNhTjeQKkC&amp;pg=PA65
  [Go]: http://golang.org/ref/spec#Semicolons

Koka will insert semicolons automatically for any statements
and declarations that are _aligned between curly braces_ ("{" and "}").
For example, in the following program:
{.grammar}

Koka will insert semicolons automatically for any statements
and declarations that are _aligned between curly braces_ ("{" and "}").
For example, in the following program:
{.grammar}


""
function eq1( x : int, y : int ) : io bool 
{  
  print("calculate equality")
  result = if (x == y) then True            
              else False
  result
}  
"

we get semicolons before each statement that was aligned between the braces:

""
function eqSemi( x : int, y : int ) : io bool 
{;  
  print("calculate equality");
  result = if (x == y) then True            
              else False;
  result;
}  
"

Since semicolons are only inserted for <em>aligned</em> statements, we can
write a long statement on multipe lines by using more indentation:

""
function eq2( x : int, y : int ) : io bool 
{  
  print("calculate " +
         "equ" +
         "ality")
  result = if (x == y)
            then True 
            else False
  result
}  
"

In contrast to token-based layout rules, as in [Scala] or [Go] for example, this
allows you to put line breaks at any point in a statement by just indenting
more. Moreover, it means that the visual indentation of a program corresponds
directly to how the compiler interprets the statements. Many tricky layout
examples in other programming languages are often based on a mismatch between
the visual representation and how a compiler interprets the tokens. With
Koka's layout rule, there is no such mismatch.

To still allow for &ldquo;block-style&rdquo; layout, the
layout rule does not insert a  semi-colon for an aligned statement if it
starts with "then", "else", "elif", or one of "{", ")", or "]".
{.grammar}

""
function foo()
{  
  val xs = [ 
    "list",
    "elements",
  ]
  if (odd(randomInt())) 
  {
    print("odd")
  }
  else 
    print("even")
}  
"

Of course, it is still allowed to use semicolons explicitly which can be used
for example to put multiple statements on a single line:

""
function equalLine( x : int, y : int ) : io bool {
  print("calculate equality"); (x == y) 
}  
"

The layout algorithm also checks for invalid layouts where the layout would
not visually correspond to how the compiler interprets the tokens. In
particular, it is illegal to indent less than the layout context or to put
comments into the indentation (because of tabs or potential unicode
characters). For example, the program:

"
function equal( x : int, y : int ) : io bool {   
    print("calculate equality")
  result = if (x == y) then True   // wrong: too little indentation
  /* wrong */      else False
    result
}  
"

is rejected. In order to facilitate code generation or source code
compression, compilers are also required to support a mode where the layout
rule is not applied and where no semicolons are inserted. A recognized command
line flag for that mode should be `--nolayout`.

### The layout algorithm

The layout rule is natural to humans since semicolon insertion corresponds
directly to the visual two-dimensional layout of the program. The formal
specification of the layout rule is a bit more technical though since a
compiler interprets source code as a linear one-dimensional sequence. To
define the layout algorithm formally, we first establish some terminology:

* A new line is started after every _linefeed_ character.
* Any non-_white_ token is called a _lexeme_, where a line without lexemes 
  is called _blank_.
* The indentation of a lexeme is the column number of its first character on 
  that line (starting at 1), and the indentation of a line is the indentation 
  of the first lexeme on the line.

Because braces can be nested, we use a _layout stack_ of strictly
increasing indentations. The top indentation on the layout stack holds the
_layout indentation_. The initial layout stack contains the single
value 0 (which is never popped). The operations on the layout stack are always
done before the semicolon insertion:

* _Layout stack operations_: If the previous lexeme was an
  open brace "{" or the start of the lexical token sequence, we push the
  indentation of the current lexeme on the layout stack. The pushed indentation
  must be larger than the previous layout indentation (unless the current lexeme
  is a closing brace).  When a closing brace "}" is encountered the top
  indentation is popped from the layout stack.

* _Semicolon insertion_: For each non-blank line, the
  indentation must be equal or larger to the layout indentation. A semicolon is
  inserted before the line whenever the indentation is equal, unless the first
  lexeme on the line is one of "then", "else", "elif", or one of "{", ")", or
  "]". Also, a semicolon is always inserted before a closing brace "}" and
  before the end of the token sequence.
{.grammar} 

As defined, semicolons are inserted whenever statements or declarations are
aligned, unless the lexeme happens to be a clear statement continuation. To
simplify the grammar specification, a semicolon is also always inserted before
a closing brace and the end of the source. This allows us to specify many
grammar elements as ended by semicolons instead of separated by semicolons
which is more difficult to specify for a LALR(1) grammar.

Semicolon insertion can be easily implemented as part of the lexer, but could
also be implemented as a straightforward transformation on the lexical token
stream. In particular, there are no intricate dependencies with the parser
that lead to bizarrely complex layout rules, as is the case in languages like
[Haskell] or [JavaScript].

## Implementation { #sec:lex-implementation }

There is a full [Flex (Lex) implementation][FlexLexer] of lexical analysis, which
includes an implementation of the layout rule. Ultimately, the Flex
implementation serves as _the_ specification, and this document and the
Flex implementation should always be in agreement.

# Context-free syntax

The grammar specification starts with the non terminal _module_ which draws
its lexical tokens from _lex_ where all _whitespace_ tokens are implicitly
ignored.

## Modules

 | | |  
--- | --- | --- | ---
_module_<sub><span class="opt">[_lex_]</span></sub> | ::= | <span class="opt">[_moduledecl_]</span> _modulebody_
&nbsp; |
_moduledecl_ | ::= | <span class="opt">[_semis_]</span>  <span  class="opt">[_visibility_]</span> "module" _moduleid_
_moduleid_ | ::= | _qvarid_ <span class="bar">&#124;</span> _varid_
&nbsp; |
_modulebody_ | ::= |  "{" <span class="opt">[_semis_]</span> _declarations_ "}" <span class="opt">[_semis_]</span>
 | &#124; | <span class="opt">[_semis_]</span> _declarations_
&nbsp; |
_visibility_ | ::= | "public" <span class="bar">&#124;</span> "private"
_semis_ | ::= | ";" <span class="many">{ ";" }</span>
{.grammar .parse}

## Top level declarations

 | | |  
--- | --- | --- | ---
_declarations_ | ::= | <span class="many">{ _import_ _semis_ }</span> <span class="many">{ _fixitydecl_ _semis_ }</span> <span class="many">{ _topdecl_ _semis_ }</span>
&nbsp; |
_import_ | ::= | <span  class="opt">[_visibility_]</span> "import" <span class="opt">[_moduleid_ "="]</span> _moduleid_
&nbsp; |
_fixitydecl_ | ::= | <span  class="opt">[_visibility_]</span> _fixity_ _natural_ _identifier_ <span class="many">{ "," _identifier_ }</span>
_fixity_ | ::= | "infixl"
 | &#124; | "infixr"
 | &#124; | "infix"
&nbsp; |
_topdecl_ | ::= | <span class="opt">[_visibility_]</span> _puredecl_
 | &#124; | <span class="opt">[_visibility_]</span> _aliasdecl_
 | &#124; | <span class="opt">[_visibility_]</span> _typedecl_
 | &#124; | <span class="opt">[_visibility_]</span> _externdecl_
 | &#124; | "abstract " _typedecl_
{.grammar .parse}

## Type declarations

 | | |  
--- | --- | --- | ---
_aliasdecl_ | ::= | "alias" _typeid_ <span class="opt">[_typeparams_]</span> <span class="opt">[_kannot_]</span> "=" _type_
_typedecl_ | ::= | _typesort_ _typeid_ <span class="opt">[_typeparams_]</span> <span class="opt">[_kannot_]</span> <span class="opt">[_typebody_]</span>
 | &#124; | "struct" _typeid_ <span class="opt">[_typeparams_]</span> <span class="opt">[_kannot_]</span> <span class="opt">[_conparams_]</span>
_typesort_ | ::= | "type" <span class="bar">&#124;</span> "cotype" <span class="bar">&#124;</span> "rectype"
&nbsp; |
_typeid_ | ::= | _varid_
 | &#124; | `[]`
 | &#124; | "(" <span class="many">{ "," }</span> ")"
 | &#124; | "<" ">"
 | &#124; | "<" <span class="koka code">&#124;</span> ">"
&nbsp; |
_typeparams_ | ::= | "<" <span class="opt"><span class="opt">[_tbinders_]</span></span> ">"
_tbinders_ | ::= | _tbinder_ <span class="many">{ "," _tbinder_ }</span>
_tbinder_ | ::= | _varid_ <span class="opt">[_kannot_]</span>
_typebody_ | ::= | "{" <span class="opt">[_semis_]</span> <span class="many">{_constructor_ _semis_ }</span> "}"
&nbsp; |
_constructor_ | ::= | <span class="opt">["con"]</span> <span class="opt">[_equantifier_]</span> _conid_ <span class="opt">[_conparams_]</span>
_conparams_ | ::= | "(" <span class="opt">[_conparam_ <span class="many">{ "," _conparam_ }</span>]</span> ")"
_conparam_ | ::= | <span class="opt">[_paramid_]</span> `:` _paramtype_ <span class="opt">["=" _expr_]</span>
{.grammar .parse}

## Value and function declarations

 | | |  
--- | --- | --- | ---
_puredecl_ | ::= | "val" _valdecl_
 | &#124; | ("fun" <span class="bar">&#124;</span> "function") _fundecl_
&nbsp; |
_valdecl_ | ::= | _binder_ "=" _expr_
_binder_ | ::= | _identifier_ <span class="opt">[`:` _type_]</span>
&nbsp; |
_fundecl_ | ::= | <span class="opt">[_quantifiers_]</span> _funid_ _fundef_ (_block_ <span class="bar">&#124;</span> "=" _blockexpr_)
_fundef_ | ::= | _parameters_ <span class="opt">[_annotres_]</span> <span class="opt">[_sigqualifier_]</span> <span class="opt">[_annotfull_]</span>
_funid_ | ::= | _identifier_
 | &#124; | `[` <span class="many">{ "," }</span> `]` | (indexing operator)
&nbsp; |
_parameters_ | ::= | "(" <span class="opt">[_parameter_ <span class="many">{ "," _parameter_ }</span>]</span> ")"
_parameter_ | ::= | _paramid_ <span class="opt">[ `:` _paramtype_]</span> <span class="opt">["=" _expr_]</span>
_paramid_ | ::= | _identifier_ <span class="bar">&#124;</span> _wildcard_
_paramtype_ | ::= | _type_
 | &#124; | "?" _type_
&nbsp; |
_annotres_ | ::= | `:` _tresult_
_annotfull_ | ::= | `::` _typesig_
&nbsp; |
_qidentifier_ | ::= | _qvarid_ <span class="bar">&#124;</span> _qidop_ <span class="bar">&#124;</span> _identifier_
_identifier_ | ::= | _varid_ <span class="bar">&#124;</span> _idop_
&nbsp; |
_qoperator_ | ::= | _op_ <span class="bar">&#124;</span> <code>&#96;</code> (_qidentifier_ <span class="bar">&#124;</span> _qconstructor_) <code>&#96;</code> 
&nbsp; |
_qconstructor_ | ::= | _conid_ <span class="bar">&#124;</span> _qconid_
{.grammar .parse}

## Statements

 | | |  
--- | --- | --- | ---
_block_ | ::= | `{` <span class="opt">[_semis_]</span> <span class="many">{ _statement_ _semis_ }</span> `}`
&nbsp; |
_statement_ | ::= | _nofunexpr_ | 
 | &#124; | _decl_ | 
&nbsp; |
_decl_ | ::= | ("fun" <span class="bar">&#124;</span> "function") _fundecl_
 | &#124; | "val" _pattern_ "=" _valexpr_ | (local values can use a pattern binding)
 | &#124; | _valdecl_ | (local values have an optional `val` keyword)
 | &#124; | "var" _binder_ `:=` _valexpr_
{.grammar .parse}

## Expressions

 | | |  
--- | --- | --- | ---
_blockexpr_ | ::= | _funexpr_
 | &#124; | _nofunexpr_ | (implicitly wrapped in a block)
&nbsp; |
_expr_ | ::= | _funexpr_
 | &#124; | _nofunexpr_ | (_returnexpr_ not allowed)
&nbsp; |
_nofunexpr_ | ::= | _matchexpr_
 | &#124; | _opexpr_
 | &#124; | _ifexpr_
 | &#124; | _returnexpr_
&nbsp; |
_noifexpr_ | ::= | _matchexpr_
 | &#124; | _opexpr_
 | &#124; | _returnexpr_
 | &#124; | _funexpr_
&nbsp; |
_ifexpr_ | ::= | "if" _atom_ _then_ <span class="many">{ _elif_ }</span> <span class="opt">["else" _noifexpr_]</span>
_then_ | ::= | <span class="opt">["then"]</span> _noifexpr_
_elif_ | ::= | "elif" _atom_ _then_
&nbsp; |
_matchexpr_ | ::= | "match" _atom_ "{" <span class="opt">[_semis_]</span> <span class="many">{ _matchrule_ _semis_ }</span> "}"
&nbsp; |
_returnexpr_ | ::= | "return" _noifexpr_ | (but no _returnexpr_ allowed)
&nbsp; |
_funexpr_ | ::= | ("fun" <span class="bar">&#124;</span> "function") <span class="opt">[_quantifiers_]</span> _fundef_ _block_
 | &#124; | _block_ | (zero-argument anonymous function)
{.grammar .parse}

## Operator expressions

For simplicity, we parse all operators as if they are left associative with
the same precedence. We assume that a separate pass in the compiler will use
the fixity declarations that are in scope to properly associate all operators
in an expressions.

 | | |  
--- | --- | --- | ---
_opexpr_ | ::= | _fappexpr_ <span class="many">{ _qoperator_ _fappexpr_ }</span>
_fappexpr_ | ::= | _appexpr_ <span class="many">{ _funexpr_ }</span>
&nbsp; |
_appexpr_ | ::= | _appexpr_ "(" <span class="opt">[_arguments_]</span> ")" | (regular application)
 | &#124; | _appexpr_ "[" <span class="opt">[_arguments_]</span> "]" | (index operation)
 | &#124; | _appexpr_ "." _prefix_
 | &#124; | _prefix_
_prefix_ | ::= | <span class="many">{ _qoperator_ }</span> _atom_
&nbsp; |
_arguments_ | ::= | _argument_ <span class="many">{ "," _argument_ }</span>
_argument_ | ::= | <span class="opt">[_identifier_ "="]</span> _expr_
{.grammar .parse}

In the grammer we use the dot (".") for both qualifying identifiers with a
module name, but also for &ldquo;dot&rdquo; expressions' where "e.f(x)" is
syntactic sugar for the application "f(e,x)". When we combine module
qualification with dot expressions, we can get expressions like
`List.primes.List.map(sqr)` where we map the squaring function over the list
of prime numbers. Note that the grammar is still LALR(1) since qualified names
are returned as single tokens by the lexical analyzer, i.e. `List.primes` and
`List.map`.

## Atomic expressions

 | | |  
--- | --- | --- | ---
_atom_ | ::= | _qidentifier_
 | &#124; | _qconstructor_
 | &#124; | _literal_
 | &#124; | "(" ")" | (unit)
 | &#124; | "(" _annexpr_ ")" | (parenthesized expression)
 | &#124; | "(" _annexprs_ ")" | (tuple expression)
 | &#124; | "[" <span class="opt">[_annexprs_ <span class="opt">[","]</span>]</span> "]" | (list expression)
&nbsp; |
_literal_ | ::= | _natural_ <span class="bar">&#124;</span> _float_ <span class="bar">&#124;</span> _char_ <span class="bar">&#124;</span> _string_
&nbsp; |
_annexprs_ | ::= | _annexpr_ <span class="many">{ "," _annexpr_ }</span>
_annexpr_ | ::= | _expr_ <span class="opt">[ `:` _typescheme_ ]</span>
{.grammar .parse}

## Matching

 | | |  
--- | --- | --- | ---
_matchrule_ | ::= | _patterns_ <span class="opt">[_guard_]</span> "->" _branchexpr_
_guard_ | ::= | <span class="koka code">&#124;</span> _compound_
&nbsp; |
_pattern_ | ::= | _identifier_
 | &#124; | _wildcard_
 | &#124; | _qconstructor_ <span class="opt">["(" [_patargs_]</span> ")"]
 | &#124; | "(" <span class="opt">[_patterns_]</span> ")" | (unit, parenthesized pattern, tuple pattern)
 | &#124; | "[" <span class="opt">[_patterns_]</span> "]" | (list pattern)
 | &#124; | _pattern_ "as" _identifier_ | (named pattern)
 | &#124; | _literal_
&nbsp; |
_patterns_ | ::= | _pattern_ <span class="many">{ "," _pattern_ }</span>
_patargs_ | ::= | _patarg_ <span class="many">{ "," _patarg_ }</span>
_patarg_ | ::= | <span class="opt">[_identifier_ "="]</span> _pattern_ | (possibly named parameter)
{.grammar .parse}

## Type schemes

 | | |  
--- | --- | --- | ---
_typesig_ | ::= | <span class="opt">[_quantifiers_]</span> _tarrow_ <span class="opt">[_sigqualifier_]</span>
_typescheme_ | ::= | <span class="opt">[_quantifiers_]</span> _tarrow_ <span class="opt">[_qualifier_]</span>
_type_ | ::= | <span class="opt">[_aquantifier_]</span> _tarrow_ <span class="opt">[_qualifier_]</span>
&nbsp; |
_quantifiers_ | ::= | <span class="opt">[_squantifier_]</span> <span class="opt">[_aquantifier_]</span>
_aquantifier_ | ::= | "forall" "<" _tbinders_ ">"
_squantifier_ | ::= | "some" "<" _tbinders_ ">"
_equantifier_ | ::= | "exists" "<" _tbinders_ ">"
&nbsp; |
_sigqualifier_ | ::= | "with" _predicates_ <span class="bar">&#124;</span> _qualifier_
_qualifier_ | ::= | "with" "(" _predicates_ ")"
&nbsp; |
_predicates_ | ::= | _predicate_ <span class="many">{ "," _predicate_ }</span>
_predicate_ | ::= | _typeapp_ | (interface)
{.grammar .parse}

## Types

 | | |  
--- | --- | --- | ---
_tarrow_  | ::= | _tatom_ <span class="opt">["->" _tresult_]</span>
_tresult_ | ::= | _tatom_ <span class="opt">[_tbasic_]</span>
&nbsp; |
_tatom_   | ::= | _tbasic_
 | &#124; | "<" _anntype_ <span class="many">{ "," _anntype_ }</span> <span class="opt">[ <span class="koka code">&#124;</span> _tatom_ ]</span> ">"
 | &#124; | "<" ">"
&nbsp; |
_tbasic_  | ::= | _typeapp_
 | &#124; | "(" ")" | (unit type)
 | &#124; | "(" _tparam_ ")" | (parenthesized type or type parameter)
 | &#124; | "(" _tparam_ <span class="many">{ "," _tparam_ }</span> ")" | (tuple type or parameters)
 | &#124; | "[" _anntype_ "]" | (list type)
&nbsp; |
_typeapp_ | ::= | _typecon_ <span class="opt">["<" [_anntype_ <span class="many">{ "," _anntype_ }</span>]</span> ">"]
&nbsp; |
_typecon_ | ::=    | _varid_ <span class="bar">&#124;</span> _qvarid_
          | &#124; | _wildcard_
          | &#124; | "(" "," <span class="many">{ "," }</span> ")" | (tuple constructor)
          | &#124; | "[" "]" | (list constructor)
          | &#124; | "(" "->" ")" | (function constructor)
&nbsp; |
_tparam_  | ::=    | <span class="opt">[_varid_ `:` ]</span> _anntype_
_anntype_ | ::=    | _type_ <span class="opt">[_kannot_]</span>
{.grammar .parse}

## Kinds

 | | |  
--- | --- | --- | ---
_kannot_ | ::= | `::` _kind_
&nbsp; |
_kind_ | ::= | "(" _kind_ <span class="many">{ "," _kind_ }</span> ")" "->" _kind_
 | &#124; | _katom_ "->" _kind_
 | &#124; | _katom_
&nbsp; |
_katom_ | ::= | "V" | (value type)
 | &#124; | "X" | (effect type)
 | &#124; | "E" | (effect row)
 | &#124; | "H" | (heap type)
 | &#124; | "P" | (predicate type)
{.grammar .parse}

## Implementation

As a companion to the Flex lexical implementation, there is a full 
[Bison(Yacc) LALR(1) implementation][BisonGrammar] 
available. Again, the Bison parser functions
as _the_ specification of the grammar and this document should always
be in agreement with that implementation.

[BisonGrammar]: https://koka.codeplex.com/SourceControl/latest#doc/spec/grammar/parser.y
[FlexLexer]:    https://koka.codeplex.com/SourceControl/latest#doc/spec/grammar/lexer.lex

# Appendix {-}

# Full grammar specification { @h1='A' } 

## Lexical syntax { #sec:full-lexical }
<div id="full-lexical"></div>

## Context-free syntax  { #sec:full-grammar }
<div id="full-grammar"></div>

</xmp>
</body>
</html>
